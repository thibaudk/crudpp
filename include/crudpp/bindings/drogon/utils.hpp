#pragma once

#include <format>

#include <json/value.h>
#include <trantor/utils/Date.h>
#include <drogon/utils/Utilities.h>

#include <crudpp/concepts.hpp>

namespace drgn
{
// adapted from models autogenerated by drogon_ctl
std::chrono::sys_days from_drgn_date(const std::string&& str)
{
    struct tm stm;
    memset(&stm,0,sizeof(stm));
    strptime(str.c_str(),"%Y-%m-%d",&stm);
    const auto t = std::chrono::system_clock::from_time_t(mktime(&stm));
    return std::chrono::time_point_cast<std::chrono::days>(t);
}

std::chrono::sys_seconds from_drgn_time(const std::string&& str)
{
    struct tm stm;
    memset(&stm,0,sizeof(stm));
    auto p = strptime(str.c_str(),"%Y-%m-%d %H:%M:%S",&stm);
    const auto t = std::chrono::system_clock::from_time_t(mktime(&stm));
    return std::chrono::time_point_cast<std::chrono::seconds>(t);
}

std::chrono::sys_time<std::chrono::milliseconds> from_drgn_time_ms(const std::string&& str)
{
    struct tm stm;
    memset(&stm,0,sizeof(stm));
    auto p = strptime(str.c_str(),"%Y-%m-%d %H:%M:%S",&stm);
    time_t t = mktime(&stm);
    size_t decimalNum = 0;
    if(p)
    {
        if(*p=='.')
        {
            std::string decimals(p+1,str[str.length()]);
            while(decimals.length()<6)
            {
                decimals += "0";
            }
            decimalNum = (size_t)atol(decimals.c_str());
        }

        t *= 1000000+decimalNum;
    }

    const auto tp = std::chrono::system_clock::from_time_t(t);
    return std::chrono::time_point_cast<std::chrono::milliseconds>(tp);
}

template <std::integral T>
T to_drgn(T v)
{ return v; }

template <typename T>
    requires std::is_enum_v<T>
int to_drgn(T v)
{ return (int)v; }

template <std::floating_point T>
T to_drgn(const T& v)
{ return v; }

template <std::same_as<std::string> T>
std::string to_drgn(const T& v)
{ return v; }

std::string to_drgn(const std::chrono::sys_days& d)
{ return std::format("{0:%F}", d); }

std::string to_drgn(const std::chrono::sys_seconds& d)
{ return std::format("{0:%F} {0:%T}", d); }

std::string to_drgn(const std::chrono::sys_time<std::chrono::milliseconds>& d)
{ return std::format("{0:%F} {0:%T}.{0:%z}", d); }

const constexpr std::string sql_pk_criteria(const std::string& s)
{ return {s + + " = ?"}; }

const constexpr std::string sql_pk_criteria(const std::vector<std::string>& v)
{
    if (v.size() == 0) assert(false);

    std::string s{ v[0] + " = ?" };

    for(int i{1}; i < v.size(); i++)
        s+= " and " + v[i] + " = ?";

    return s;
}

template <std::size_t I>
bool asign_from_params(auto&& f,
                       const drogon::SafeStringMap<std::string>& parameters,
                       const std::vector<std::string>& names)
{
    auto iter = parameters.find(names[I]);
    if(iter == parameters.end()) return false;

    try
    {
        f = std::stoll(iter->second);
        return true;
    }
    catch(...) { return false; };
}
} // namespace drgn
